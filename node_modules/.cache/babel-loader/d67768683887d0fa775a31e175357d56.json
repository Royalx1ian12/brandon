{"ast":null,"code":"var _classCallCheck = require(\"D:/jobStuff/hoichistakes/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/jobStuff/hoichistakes/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _regeneratorRuntime = require(\"D:\\\\jobStuff\\\\hoichistakes\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\nvar _asyncToGenerator = require(\"D:/jobStuff/hoichistakes/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar cacheUtils = require('./cache-utils.js');\nvar createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nvar emptyValues = [undefined, null, \"<nil>\"];\nmodule.exports = createBlockCacheMiddleware;\nfunction createBlockCacheMiddleware() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // validate options\n  var blockTracker = opts.blockTracker;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified');\n\n  // create caching strategies\n  var blockCache = new BlockCacheStrategy();\n  var strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res, next) {\n      var type, strategy, blockTag, requestedBlockNumber, latestBlockNumber, cacheResult;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!req.skipCache) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", next());\n            case 2:\n              // check type and matching strategy\n              type = cacheUtils.cacheTypeForPayload(req);\n              strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.\n              if (strategy) {\n                _context.next = 6;\n                break;\n              }\n              return _context.abrupt(\"return\", next());\n            case 6:\n              if (strategy.canCacheRequest(req)) {\n                _context.next = 8;\n                break;\n              }\n              return _context.abrupt(\"return\", next());\n            case 8:\n              // get block reference (number or keyword)\n              blockTag = cacheUtils.blockTagForPayload(req);\n              if (!blockTag) blockTag = 'latest';\n\n              // get exact block number\n              if (!(blockTag === 'earliest')) {\n                _context.next = 14;\n                break;\n              }\n              // this just exists for symmetry with \"latest\"\n              requestedBlockNumber = '0x00';\n              _context.next = 23;\n              break;\n            case 14:\n              if (!(blockTag === 'latest')) {\n                _context.next = 22;\n                break;\n              }\n              _context.next = 17;\n              return blockTracker.getLatestBlock();\n            case 17:\n              latestBlockNumber = _context.sent;\n              // clear all cache before latest block\n              blockCache.clearBefore(latestBlockNumber);\n              requestedBlockNumber = latestBlockNumber;\n              _context.next = 23;\n              break;\n            case 22:\n              // We have a hex number\n              requestedBlockNumber = blockTag;\n            case 23:\n              _context.next = 25;\n              return strategy.get(req, requestedBlockNumber);\n            case 25:\n              cacheResult = _context.sent;\n              if (!(cacheResult === undefined)) {\n                _context.next = 33;\n                break;\n              }\n              _context.next = 29;\n              return next();\n            case 29:\n              _context.next = 31;\n              return strategy.set(req, requestedBlockNumber, res.result);\n            case 31:\n              _context.next = 34;\n              break;\n            case 33:\n              // fill in result from cache\n              res.result = cacheResult;\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}\n\n//\n// Cache Strategies\n//\nvar BlockCacheStrategy = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function BlockCacheStrategy() {\n    _classCallCheck(this, BlockCacheStrategy);\n    this.cache = {};\n  }\n  _createClass(BlockCacheStrategy, [{\n    key: \"getBlockCacheForPayload\",\n    value: function getBlockCacheForPayload(payload, blockNumberHex) {\n      var blockNumber = Number.parseInt(blockNumberHex, 16);\n      var blockCache = this.cache[blockNumber];\n      // create new cache if necesary\n      if (!blockCache) {\n        var newCache = {};\n        this.cache[blockNumber] = newCache;\n        blockCache = newCache;\n      }\n      return blockCache;\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, requestedBlockNumber) {\n        var blockCache, identifier, cached;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // lookup block cache\n                blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n                if (blockCache) {\n                  _context2.next = 3;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 3:\n                // lookup payload in block cache\n                identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n                cached = blockCache[identifier]; // may be undefined\n                return _context2.abrupt(\"return\", cached);\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function get(_x4, _x5) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(payload, requestedBlockNumber, result) {\n        var canCache, blockCache, identifier;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // check if we can cached this result\n                canCache = this.canCacheResult(payload, result);\n                if (canCache) {\n                  _context3.next = 3;\n                  break;\n                }\n                return _context3.abrupt(\"return\");\n              case 3:\n                // set the value in the cache\n                blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n                identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n                blockCache[identifier] = result;\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function set(_x6, _x7, _x8) {\n        return _set.apply(this, arguments);\n      }\n      return set;\n    }()\n  }, {\n    key: \"canCacheRequest\",\n    value: function canCacheRequest(payload) {\n      // check request method\n      if (!cacheUtils.canCache(payload)) {\n        return false;\n      }\n      // check blockTag\n      var blockTag = cacheUtils.blockTagForPayload(payload);\n      if (blockTag === 'pending') {\n        return false;\n      }\n      // can be cached\n      return true;\n    }\n  }, {\n    key: \"canCacheResult\",\n    value: function canCacheResult(payload, result) {\n      // never cache empty values (e.g. undefined)\n      if (emptyValues.includes(result)) return;\n      // check if transactions have block reference before caching\n      if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n        if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n          return false;\n        }\n      }\n      // otherwise true\n      return true;\n    }\n\n    // removes all block caches with block number lower than `oldBlockHex`\n  }, {\n    key: \"clearBefore\",\n    value: function clearBefore(oldBlockHex) {\n      var self = this;\n      var oldBlockNumber = Number.parseInt(oldBlockHex, 16);\n      // clear old caches\n      Object.keys(self.cache).map(Number).filter(function (num) {\n        return num < oldBlockNumber;\n      }).forEach(function (num) {\n        return delete self.cache[num];\n      });\n    }\n  }]);\n  return BlockCacheStrategy;\n}();","map":{"version":3,"names":["cacheUtils","require","createAsyncMiddleware","emptyValues","undefined","module","exports","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","getLatestBlock","latestBlockNumber","clearBefore","get","cacheResult","set","result","cache","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","getBlockCacheForPayload","identifier","cacheIdentifierForPayload","cached","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"],"sources":["D:/jobStuff/hoichistakes/node_modules/eth-json-rpc-middleware/block-cache.js"],"sourcesContent":["const cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n"],"mappings":";;;;AAAA,IAAMA,UAAU,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC9C,IAAMC,qBAAqB,GAAGD,OAAO,CAAC,2CAA2C,CAAC;AAClF;AACA,IAAME,WAAW,GAAG,CAACC,SAAS,EAAE,IAAI,EAAE,OAAiB,CAAC;AAExDC,MAAM,CAACC,OAAO,GAAGC,0BAA0B;AAG3C,SAASA,0BAA0B,GAAY;EAAA,IAAXC,IAAI,uEAAG,CAAC,CAAC;EAC3C;EACA,IAAQC,YAAY,GAAKD,IAAI,CAArBC,YAAY;EACpB,IAAI,CAACA,YAAY,EAAE,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;;EAE5F;EACA,IAAMC,UAAU,GAAG,IAAIC,kBAAkB,EAAE;EAC3C,IAAMC,UAAU,GAAG;IACjBC,KAAK,EAAEH,UAAU;IACjBI,KAAK,EAAEJ,UAAU;IACjBK,IAAI,EAAEL;EACR,CAAC;EAED,OAAOT,qBAAqB;IAAA,oEAAC,iBAAOe,GAAG,EAAEC,GAAG,EAAEC,IAAI;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,KAE5CF,GAAG,CAACG,SAAS;gBAAA;gBAAA;cAAA;cAAA,iCACRD,IAAI,EAAE;YAAA;cAEf;cACME,IAAI,GAAGrB,UAAU,CAACsB,mBAAmB,CAACL,GAAG,CAAC;cAC1CM,QAAQ,GAAGV,UAAU,CAACQ,IAAI,CAAC,EACjC;cAAA,IACKE,QAAQ;gBAAA;gBAAA;cAAA;cAAA,iCACJJ,IAAI,EAAE;YAAA;cAAA,IAGVI,QAAQ,CAACC,eAAe,CAACP,GAAG,CAAC;gBAAA;gBAAA;cAAA;cAAA,iCACzBE,IAAI,EAAE;YAAA;cAGf;cACIM,QAAQ,GAAGzB,UAAU,CAAC0B,kBAAkB,CAACT,GAAG,CAAC;cACjD,IAAI,CAACQ,QAAQ,EAAEA,QAAQ,GAAG,QAAQ;;cAElC;cAAA,MAEIA,QAAQ,KAAK,UAAU;gBAAA;gBAAA;cAAA;cACzB;cACAE,oBAAoB,GAAG,MAAM;cAAA;cAAA;YAAA;cAAA,MACpBF,QAAQ,KAAK,QAAQ;gBAAA;gBAAA;cAAA;cAAA;cAAA,OAEEhB,YAAY,CAACmB,cAAc,EAAE;YAAA;cAAvDC,iBAAiB;cACvB;cACAlB,UAAU,CAACmB,WAAW,CAACD,iBAAiB,CAAC;cACzCF,oBAAoB,GAAGE,iBAAiB;cAAA;cAAA;YAAA;cAExC;cACAF,oBAAoB,GAAGF,QAAQ;YAAA;cAAA;cAAA,OAIPF,QAAQ,CAACQ,GAAG,CAACd,GAAG,EAAEU,oBAAoB,CAAC;YAAA;cAA3DK,WAAW;cAAA,MACbA,WAAW,KAAK5B,SAAS;gBAAA;gBAAA;cAAA;cAAA;cAAA,OAGrBe,IAAI,EAAE;YAAA;cAAA;cAAA,OAENI,QAAQ,CAACU,GAAG,CAAChB,GAAG,EAAEU,oBAAoB,EAAET,GAAG,CAACgB,MAAM,CAAC;YAAA;cAAA;cAAA;YAAA;cAEzD;cACAhB,GAAG,CAACgB,MAAM,GAAGF,WAAW;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAE3B;IAAA;MAAA;IAAA;EAAA,IAAC;AACJ;;AAGA;AACA;AACA;AAAA,IAEMpB,kBAAkB;EAAA;;EAEtB,8BAAe;IAAA;IACb,IAAI,CAACuB,KAAK,GAAG,CAAC,CAAC;EACjB;EAAC;IAAA;IAAA,OAED,iCAAyBC,OAAO,EAAEC,cAAc,EAAE;MAChD,IAAMC,WAAW,GAAGC,MAAM,CAACC,QAAQ,CAACH,cAAc,EAAE,EAAE,CAAC;MACvD,IAAI1B,UAAU,GAAG,IAAI,CAACwB,KAAK,CAACG,WAAW,CAAC;MACxC;MACA,IAAI,CAAC3B,UAAU,EAAE;QACf,IAAM8B,QAAQ,GAAG,CAAC,CAAC;QACnB,IAAI,CAACN,KAAK,CAACG,WAAW,CAAC,GAAGG,QAAQ;QAClC9B,UAAU,GAAG8B,QAAQ;MACvB;MACA,OAAO9B,UAAU;IACnB;EAAC;IAAA;IAAA;MAAA,oEAED,kBAAWyB,OAAO,EAAET,oBAAoB;QAAA;QAAA;UAAA;YAAA;cAAA;gBACtC;gBACMhB,UAAU,GAAG,IAAI,CAAC+B,uBAAuB,CAACN,OAAO,EAAET,oBAAoB,CAAC;gBAAA,IACzEhB,UAAU;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBACf;gBACMgC,UAAU,GAAG3C,UAAU,CAAC4C,yBAAyB,CAACR,OAAO,EAAE,IAAI,CAAC;gBAChES,MAAM,GAAGlC,UAAU,CAACgC,UAAU,CAAC,EACrC;gBAAA,kCACOE,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,oEAED,kBAAWT,OAAO,EAAET,oBAAoB,EAAEO,MAAM;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC9C;gBACMY,QAAQ,GAAG,IAAI,CAACC,cAAc,CAACX,OAAO,EAAEF,MAAM,CAAC;gBAAA,IAChDY,QAAQ;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBACb;gBACMnC,UAAU,GAAG,IAAI,CAAC+B,uBAAuB,CAACN,OAAO,EAAET,oBAAoB,CAAC;gBACxEgB,UAAU,GAAG3C,UAAU,CAAC4C,yBAAyB,CAACR,OAAO,EAAE,IAAI,CAAC;gBACtEzB,UAAU,CAACgC,UAAU,CAAC,GAAGT,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAChC;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAED,yBAAiBE,OAAO,EAAE;MACxB;MACA,IAAI,CAACpC,UAAU,CAAC8C,QAAQ,CAACV,OAAO,CAAC,EAAE;QACjC,OAAO,KAAK;MACd;MACA;MACA,IAAMX,QAAQ,GAAGzB,UAAU,CAAC0B,kBAAkB,CAACU,OAAO,CAAC;MACvD,IAAIX,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,KAAK;MACd;MACA;MACA,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAED,wBAAgBW,OAAO,EAAEF,MAAM,EAAE;MAC/B;MACA,IAAI/B,WAAW,CAAC6C,QAAQ,CAACd,MAAM,CAAC,EAAE;MAClC;MACA,IAAI,CAAC,0BAA0B,EAAE,2BAA2B,CAAC,CAACc,QAAQ,CAACZ,OAAO,CAACa,MAAM,CAAC,EAAE;QACtF,IAAI,CAACf,MAAM,IAAI,CAACA,MAAM,CAACgB,SAAS,IAAIhB,MAAM,CAACgB,SAAS,KAAK,oEAAoE,EAAE;UAC7H,OAAO,KAAK;QACd;MACF;MACA;MACA,OAAO,IAAI;IACb;;IAEA;EAAA;IAAA;IAAA,OACA,qBAAaC,WAAW,EAAC;MACvB,IAAMC,IAAI,GAAG,IAAI;MACjB,IAAMC,cAAc,GAAGd,MAAM,CAACC,QAAQ,CAACW,WAAW,EAAE,EAAE,CAAC;MACvD;MACAG,MAAM,CAACC,IAAI,CAACH,IAAI,CAACjB,KAAK,CAAC,CACpBqB,GAAG,CAACjB,MAAM,CAAC,CACXkB,MAAM,CAAC,UAAAC,GAAG;QAAA,OAAIA,GAAG,GAAGL,cAAc;MAAA,EAAC,CACnCM,OAAO,CAAC,UAAAD,GAAG;QAAA,OAAI,OAAON,IAAI,CAACjB,KAAK,CAACuB,GAAG,CAAC;MAAA,EAAC;IAC3C;EAAC;EAAA;AAAA"},"metadata":{},"sourceType":"script"}