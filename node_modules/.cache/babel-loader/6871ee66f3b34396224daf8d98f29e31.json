{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/jobStuff/hoichistakes/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/jobStuff/hoichistakes/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar mh = require('multihashes');\nvar multibase = require('multibase');\nvar multicodec = require('multicodec');\nvar codecs = require('multicodec/src/base-table.json');\nvar CIDUtil = require('./cid-util');\nvar withIs = require('class-is');\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nvar CID = /*#__PURE__*/function (_Symbol$for) {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Buffer|CID} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  function CID(version, codec, multihash, multibaseName) {\n    _classCallCheck(this, CID);\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      var cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash);\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      var baseName = multibase.isEncoded(version);\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        var _cid = multibase.decode(version);\n        this.version = parseInt(_cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(_cid.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n    if (Buffer.isBuffer(version)) {\n      var firstByte = version.slice(0, 1);\n      var v = parseInt(firstByte.toString('hex'), 16);\n      if (v === 1) {\n        // version is a CID buffer\n        var _cid2 = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(_cid2.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid2.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      return;\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n    this.version = version;\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec;\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash;\n\n    /**\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  _createClass(CID, [{\n    key: \"buffer\",\n    get: function get() {\n      var buffer = this._buffer;\n      if (!buffer) {\n        if (this.version === 0) {\n          buffer = this.multihash;\n        } else if (this.version === 1) {\n          buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n        } else {\n          throw new Error('unsupported version');\n        }\n\n        // Cache this buffer so it doesn't have to be recreated\n        Object.defineProperty(this, '_buffer', {\n          value: buffer\n        });\n      }\n      return buffer;\n    }\n\n    /**\n     * Get the prefix of the CID.\n     *\n     * @returns {Buffer}\n     * @readonly\n     */\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return Buffer.concat([Buffer.from(\"0\".concat(this.version), 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n    }\n\n    /**\n     * Convert to a CID of version `0`.\n     *\n     * @returns {CID}\n     */\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n      var _mh$decode = mh.decode(this.multihash),\n        name = _mh$decode.name,\n        length = _mh$decode.length;\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n      return new _CID(0, this.codec, this.multihash);\n    }\n\n    /**\n     * Convert to a CID of version `1`.\n     *\n     * @returns {CID}\n     */\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new _CID(1, this.codec, this.multihash);\n    }\n\n    /**\n     * Encode the CID into a string.\n     *\n     * @param {string} [base=this.multibaseName] - Base encoding to use.\n     * @returns {string}\n     */\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n      if (this.string && base === this.multibaseName) {\n        return this.string;\n      }\n      var str = null;\n      if (this.version === 0) {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n        }\n        str = mh.toB58String(this.multihash);\n      } else if (this.version === 1) {\n        str = multibase.encode(base, this.buffer).toString();\n      } else {\n        throw new Error('unsupported version');\n      }\n      if (base === this.multibaseName) {\n        // cache the string value\n        Object.defineProperty(this, 'string', {\n          value: str\n        });\n      }\n      return str;\n    }\n\n    /**\n     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n     *\n     * @returns {String}\n     */\n  }, {\n    key: _Symbol$for,\n    value: function value() {\n      return 'CID(' + this.toString() + ')';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n\n    /**\n     * Serialize to a plain object.\n     *\n     * @returns {SerializedCID}\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n\n    /**\n     * Compare equality with another CID.\n     *\n     * @param {CID} other\n     * @returns {bool}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n    }\n\n    /**\n     * Test if the given input is a valid CID object.\n     * Throws if it is not.\n     *\n     * @param {any} other\n     * @returns {void}\n     */\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n  }]);\n  return CID;\n}(Symbol.for('nodejs.util.inspect.custom'));\nvar _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"names":["require","Buffer","mh","multibase","multicodec","codecs","CIDUtil","withIs","CID","version","codec","multihash","multibaseName","_CID","isCID","cid","from","baseName","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","validateCID","Object","defineProperty","value","isBuffer","firstByte","v","buffer","_buffer","concat","getCodeVarint","Error","prefix","name","length","base","string","str","toB58String","encode","toBaseEncodedString","hash","other","equals","errorMsg","checkCIDComponents","Symbol","for","className","symbolName","module","exports"],"sources":["D:/jobStuff/hoichistakes/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst codecs = require('multicodec/src/base-table.json')\nconst CIDUtil = require('./cid-util')\nconst withIs = require('class-is')\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Buffer|CID} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor (version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = Buffer.from(cid.multihash)\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\n      return\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version)\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version)\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = baseName\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = mh.fromB58String(version)\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      Object.defineProperty(this, 'string', { value: version })\n      return\n    }\n\n    if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1)\n      const v = parseInt(firstByte.toString('hex'), 16)\n      if (v === 1) {\n        // version is a CID buffer\n        const cid = version\n        this.version = v\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = 'base32'\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = version\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      return\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n    this.version = version\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash\n\n    /**\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get buffer () {\n    let buffer = this._buffer\n\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([\n          Buffer.from('01', 'hex'),\n          multicodec.getCodeVarint(this.codec),\n          this.multihash\n        ])\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', { value: buffer })\n    }\n\n    return buffer\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n  get prefix () {\n    return Buffer.concat([\n      Buffer.from(`0${this.version}`, 'hex'),\n      multicodec.getCodeVarint(this.codec),\n      mh.prefix(this.multihash)\n    ])\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new _CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new _CID(1, this.codec, this.multihash)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base = this.multibaseName) {\n    if (this.string && base === this.multibaseName) {\n      return this.string\n    }\n    let str = null\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n      }\n      str = mh.toB58String(this.multihash)\n    } else if (this.version === 1) {\n      str = multibase.encode(base, this.buffer).toString()\n    } else {\n      throw new Error('unsupported version')\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', { value: str })\n    }\n    return str\n  }\n\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {String}\n   */\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return 'CID(' + this.toString() + ')'\n  }\n\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      this.multihash.equals(other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID (other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n})\n\n_CID.codecs = codecs\n\nmodule.exports = _CID\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}